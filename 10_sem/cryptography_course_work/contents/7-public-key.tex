\section{Перенос результатов на коммутативное
           шифрование с открытым ключом}

В этом разделе мы переносим результаты, полученные в §4 и §5 для
возведения в степень Диффи–Хеллмана, на коммутативное
шифрование с открытым ключом (например, RSA с общим модулем).
Покажем, что задача \textsc{Insecure} остаётся NP\=/полной, а задача
вывода — т.е. определение, выводится ли данное сообщение из конечного
набора сообщений — может решаться эффективно. Эти результаты
достигаются при небольшой модификации моделей и доказательств,
представленных выше. Возможность переноса объясняется тем, что
возведение в степень Диффи–Хеллмана и коммутативное шифрование
с открытым ключом (в случае RSA также основанное на возведении в
степень) обладают сходными алгебраическими свойствами.
Будем интерпретировать операцию возведения в степень
$c=\operatorname{Exp}(m,k_{A})$ как шифрование сообщения $m$
публичным ключом $k_{A}$, где $k_{A}'$ — соответствующий
закрытый ключ. Вычисляя
\(\operatorname{Exp}(c,k_{A}')=
  \operatorname{Exp}(m,k_{A}\cdot k_{A}')=
  \operatorname{Exp}(m,1)=m\),
мы расшифровываем $c$ и получаем открытый текст $m$.
Коммутативность шифрования даёт эквивалентность
\(\operatorname{Exp}(\operatorname{Exp}(m,k_{A}),k_{B})\) и
\(\operatorname{Exp}(\operatorname{Exp}(m,k_{B}),k_{A})\)
в рамках рассматриваемых алгебраических свойств.
Из-за такого толкования возведения в степень при
коммутативном шифровании возникают некоторые отличия.

Во-первых, возможности нарушителя различаются.  
При коммутативном шифровании с открытым ключом нарушитель не в
состоянии вычислять обратные показатели степени: имея публичный ключ
\((n,e)\) и шифротекст \(c \equiv m^{e}\pmod n\), он не может найти закрытый
ключ \(d\) и затем, вычислив \(c^{d}\bmod n\), восстановить сообщение \(m\).
Напротив, в случае Диффи–Хеллмана возведение в степень выполняется по
модулю общедоступного простого числа, поэтому нарушитель может
эффективно получить обратный показатель. Например, имея
\(m=g^{\,a\cdot b}\) и \(b\) (где \(g\) порождает мультипликативную группу по
модулю \(p\)), он вычисляет обратный элемент \(b^{-1}\) по модулю \(p-1\)
(если обратный существует) и получает \(m^{\,b^{-1}}=g^{\,a}\).

Во-вторых, в рассмотренной ранее модели нарушитель не располагает
явными обратными элементами сообщений, такими как \(b^{-1}\), поскольку
его знания ограничены стандартными сообщениями.  Однако в модели
коммутативного шифрования c открытым ключом такое ограничение слишком
жёстко: обратные элементы соответствуют закрытым ключам, и мы должны
разрешить нарушителю владеть этими ключами — как собственными,
так и ключами нечестных участников.

Ниже мы приведём два простых примера, демонстрирующих применение
коммутативных схем шифрования с открытым ключом в криптографических
протоколах, затем обозначим изменения, необходимые в наших моделях
протокола и нарушителя, и, наконец, сформулируем основные результаты
данного раздела.

\subsection{Примеры протоколов, использующих коммутативное шифрование с открытым ключом}

Два следующих примера заимствованы из книги \cite{Schneier1996}.  
Первый протокол принадлежит Шамиру. Его цель — обеспечить защищённую
связь между двумя агентами, которые не делят симметрический ключ и не
знают открытый ключ друг друга. Протокол опирается на
коммутативность шифрования в системе RSA и состоит из трёх сообщений:
\[
\begin{array}{ll}
1.& A \;\rightarrow\; B :\; Exp(\mathit{secret},K_{A}) \\[2pt]
2.& B \;\rightarrow\; A :\; Exp\!\bigl(Exp(\mathit{secret},K_{A}),K_{B}\bigr) \\[2pt]
3.& A \;\rightarrow\; B :\; Exp(\mathit{secret},K_{B})
\end{array}
\]

В протоколе предполагается общий модуль $n$ (типичен для RSA).  
Публичный ключ $A$ — пара $(n,K_{A})$, публичный ключ $B$ — пара
$(n,K_{B})$. Сообщение $\mathit{secret}$ есть неотрицательное целое,
меньшее $n$; выражение $Exp(\mathit{secret},K_{A})$ обозначает
$\mathit{secret}^{\,K_{A}}\bmod n$.  
Благодаря алгебраическим свойствам возведения в степень имеем
\(
   Exp\!\bigl(Exp(\mathit{secret},K_{A}),K_{B}\bigr)
    = Exp(\mathit{secret},K_{A}\!\cdot K_{B})
    = Exp\!\bigl(Exp(\mathit{secret},K_{B}),K_{A}\bigr).
\)

На шаге 3 участник $A$ вычисляет
\(
   Exp\!\Bigl(
      Exp\!\bigl(Exp(\mathit{secret},K_{A}),K_{B}\bigr),
      K_{A}'\Bigr)
   = Exp(\mathit{secret},K_{A}\!\cdot K_{B}\!\cdot K_{A}')
   = Exp(\mathit{secret},K_{B}),
\)
где $K_{A}'$ — закрытый ключ $A$. Протокол, тем самым, сам использует
коммутативность шифрования.  
Поскольку $B$ в протоколе никак не аутентифицируется,
нарушитель способен выдать себя за $B$, просто играя роль $B$ и
используя собственный открытый ключ $K_{I}$. Таким образом,
протокол уязвим, и эта атака легко обнаруживается нашей
процедурой вывода.

Коммутативная система шифрования с открытым ключом (или схема подписи) 
может оказаться полезной и в групповых протоколах. 
По мотивам описанного в \cite[гл.~23]{Schneier1996} протокола 
рассмотрим группу из~$l$ агентов. 
Доверенный сервер генерирует два больших простых числа $p$ и~$q$, 
вычисляет $n = p\cdot q$ и подбирает $l+1$ чисел 
$k_{0},\dots,k_{l}$ так, что 
\[
  k_{0}\cdots k_{l}\equiv 1 \pmod{(p-1)\,(q-1)}.
\] 
Каждому агенту $A_{i}$, $1\le i\le l$, для каждого~$j$ выдаются
публичные ключи $K_{j}$, равные произведению всех $k_{0}\dots k_{l}$, 
кроме $k_{j}$, и собственный закрытый ключ $k_{i}$. 
При этом 
\[
  Exp\bigl(M,\,k_{0}\cdots k_{l}\bigr)=M,
\]
и, в частности,
\[
   Exp\!\bigl(Exp(M,k_{i}),K_{i}\bigr)=
   Exp\!\bigl(M,\,k_{i}\!\cdot\!K_{i}\bigr)=M.
\]

После того как распределение ключей завершено, сообщение может быть
подписано подмножеством членов группы
$\{A_{i}\mid i\in\{1,\dots,l\}\}$.
Предположим, к примеру, что $l=4$ и $A_{1}$ хочет подписать
документ~$M$ совместно с $A_{2}$ и~$A_{4}$.
Возможная последовательность сообщений такова:  

\[
\begin{array}{ll}
1.& A_{1}\rightarrow A_{2}: Exp(M,k_{1});\\
2.& A_{2}\rightarrow A_{4}: Exp\!\bigl(Exp(M,k_{1}),k_{2}\bigr);\\
3.& A_{4}\rightarrow A_{1}: Exp\!\bigl(Exp\!\bigl(Exp(M,k_{1}),k_{2}\bigr),k_{4}\bigr).
\end{array}
\]

Получив второе сообщение, агент $A_{4}$ может проверить подписи и
личности агентов, подписавших~$M$, проверив равенство
\[
   Exp\!\Bigl(Exp\!\Bigl(Exp\!\bigl(Exp(M,k_{1}),k_{2}\bigr),K_{1}\Bigr),K_{2})
     = Exp\!\bigl(M,\,k_{1}\cdot K_{1}\cdot k_{2}\cdot K_{2}\bigr)
     = M.
\]
После этого $A_{4}$ при желании подписывает контракт своим закрытым
ключом~$k_{4}$. Важно, что благодаря коммутативности операции
шифрования $A_{4}$ необязательно знать порядок, в котором остальные
участники накладывали подписи.  
Разумеется, если рассматривать указанный обмен как протокол
подписания контракта, то у него возникает множество проблем;
однако их обсуждение выходит за рамки данной работы.

\subsection{Модель протокола и нарушителя для схем
             с коммутативным шифрованием}

Ниже мы формально определяем нашу модель, задавая понятия термов,
сообщений, протоколов, нарушителя и атак.

\textit{Термы и сообщения.} Определения близки к приведённым в
§\,2.1. Оператор открытого-ключевого шифрования \(\{m\}_{k^{P}}\) опускается,
поскольку теперь его заменяет форма \(Exp(m,k)\).
При желании этот оператор можно было бы сохранить, чтобы моделировать
некоммутативное шифрование, но ради краткости мы его опустим.
Главное отличие состоит в том, что показатели степеней ограничены
только неотрицательными целыми — это обусловлено тем, что,
в отличие от ситуации Диффи–Хеллмана, инвертирование показателей
здесь вычислительно неосуществимо
(см. ниже дополнительное пояснение).

Формально задаём

\[
\begin{array}{lcl}
\mathit{term} &::=&
      \mathcal A
      \mid \mathcal V
      \mid \langle\mathit{term},\mathit{term}\rangle
      \mid \{\mathit{term}\}^{s}_{\mathit{term}}
      \mid Exp(\mathit{term},\mathit{product}),
\\[2pt]
\mathit{product} &::=&
      \mathit{term}^{\mathbb N}
      \mid \mathit{term}^{\mathbb N}\!\cdot \mathit{product},
\end{array}
\]

где $\mathcal A$ — конечное множество констант (атомарных сообщений),
включающее имена субъектов, одноразовые числа, ключи, а также
константы $1$ и \textit{secret};
$\mathcal K\subseteq\mathcal A$ — подмножество,
содержащее все открытые и закрытые ключи;
$\mathcal V$ — конечное множество переменных;
$\mathbb N$ — множество неотрицательных целых.
Предполагается наличие биекции $\,{\cdot}':\mathcal K\rightarrow\mathcal K$,
которая каждому открытому (закрытому) ключу $k$ сопоставляет
соответствующий закрытый (открытый) ключ $k'$.

Как отмечалось, оператор $Exp(\,\,\cdot\,,\,\cdot\,)$
теперь интерпретируется как коммутативное шифрование
с открытым ключом.
Поэтому показатели степеней в произведениях ограничиваются
неотрицательными целыми:
расшифровать сообщение $Exp(m,k)$ без знания закрытого ключа $k'$
практически невозможно даже при наличии открытого ключа $k$.
Напомним, что в Диффи–Хеллмановской модели,
получив $k$, любой — включая нарушителя — мог вычислить $k^{-1}$ и тем
самым восстановить исходное сообщение:
\(
   Exp\!\bigl(Exp(m,k),k^{-1}\bigr)=
   Exp\!\bigl(m,\,k\cdot k^{-1}\bigr)=
   Exp(m,1)=m.
\).
Однако, если субъект располагает \emph{закрытым} ключом $k'$,  
он способен «обратить» показатель степени.
Чтобы отразить это, мы рассматриваем закрытые ключи как
атомарные сообщения $k'$ (а не как формальные обратные элементы
$k^{-1}$) и расширяем функцию нормализации так, чтобы в показателях
степеней открытые и соответствующие им закрытые ключи сокращались.
Иными словами,
\(
   Exp\!\bigl(Exp(m,k),k'\bigr)=
   Exp\!\bigl(m,k\cdot k'\bigr)=
   Exp(m,1)=m.
\)

Более формально, мы фиксируем следующий набор алгебраических
свойств.  Они включают свойства, принятые для возведения в степень
Диффи–Хеллмана (§\,2.1), и дополнительно тождество
\(
   k\cdot k' = 1,
\)
где $k'$ — закрытый (открытый) ключ, соответствующий открытому
(закрытому) ключу $k$.
Таким образом, наряду с коммутативностью и ассоциативностью оператора
произведения мы предполагаем следующие равенства, где
$t$ — стандартный терм,
$M_{1},M_{2}$ — произведения,
$k,k'\in\mathcal K$ определены выше,
а $z,z'$ — неотрицательные целые:

\[
\begin{array}{@{}ll@{\qquad}l@{}}
t^{1}=t              & t\!\cdot\! 1 = t
                     & Exp(t,1) = t \\[2pt]
t^{0}=1              & t^{z}\!\cdot t^{z'} = t^{\,z+z'}
                     & Exp\!\bigl(Exp(t,M_{1}),M_{2}\bigr)
                       = Exp(t,M_{1}\!\cdot M_{2}) \\[2pt]
1^{z}=1              & k\!\cdot\! k' = 1 &
\end{array}
\]

Нормальной формой $\ulcorner t\urcorner$ терма $t$
(как и в случае возведения в степень Диффи–Хеллмана)
называется результат исчерпывающего применения приведённых выше
тождеств «слева направо».
Нормальная форма однозначно определяется
с точностью до коммутативности и ассоциативности оператора
произведения.  
Термы $t$ и $t'$ считаются \emph{эквивалентными},
если $\ulcorner t\urcorner=\ulcorner t'\urcorner$.
Понятие нормальной формы естественно распространяется
на множества термов и подстановки.

Ниже приведены примеры нормализации; пусть $a,b,c,d\in\mathcal K$:
\[
\begin{aligned}
(1)\;& \ulcorner(a^{2}\!\cdot b)\cdot b^{2}\urcorner = a^{2}\!\cdot b',\\[2pt]
(2)\;& Exp\!\bigl(Exp(a,(b^{1}\!\cdot c)^{\,1}),c^{\,d^{2}}\bigr)
        = Exp(a,b\!\cdot d^{2}),\\[2pt]
(3)\;& Exp\!\bigl(Exp\bigl(Exp(a,b^{3}\!\cdot c^{\,6}),b^{5}\bigr),c^{5}\bigr)=a.
\end{aligned}
\]

Заметим, что, например, $b'$ обозначает
закрытый ключ, соответствующий открытому ключу~$b$.

\textit{Протоколы}. Протоколы определяются так же, как в~Определении 2.6.  

В нашей модели протоколов RSA-процедура (пункт 7.1) формально
задаётся следующим образом:
предположим, что $A$ выполняет один экземпляр протокола как
инициатор, а $B$ — один экземпляр как респондент.
Протокол состоит из трёх правил, обозначаемых
\((A,1)\), \((A,2)\) и \((B,1)\):

\[
\begin{array}{@{}ll@{\quad}l@{}}
(A,1): & 1 \;\Longrightarrow\; Exp(\mathit{secret},K_{A}),\\[2pt]
(A,2): & x \;\Longrightarrow\; Exp(x,K_{A}'),\\[2pt]
(B,1): & y \;\Longrightarrow\; Exp(y,K_{B}),
\end{array}
\]

где \((A,1)\) и \((A,2)\) — первый и второй шаги агента~$A$,
а \((B,1)\) — шаг агента~$B$.
Частичный порядок задаётся множеством 
\(\leqslant=\{((A,1),(A,2))\}\), то есть единственным
требованием \((A,1)<(A,2)\); это гарантирует,
что правило \((A,1)\) должно быть выполнено до \((A,2)\).
Начальные знания нарушителя равны
\(\{1,\,K_{I},\,K_{I}'\}\); помимо константы~$1$
нарушитель знает свой открытый и закрытый ключи.

\textit{Модель нарушителя и атаки}. Пусть $E$ — конечное нормализованное множество сообщений.
(Infinite) множество сообщений \(\mathit{forge}(E)\), которые нарушитель
может вывести из $E$, определяется так же, как и для возведения в степень
Диффи–Хеллмана, за исключением того, что показатели $z_{i}$, возникающие
в оракульных правилах, теперь ограничены неотрицательными целыми
(см.~Определение 4.1).  Нарушителя, получаемого таким образом,
далее будем называть \emph{RSA-нарушителем}.

Понятия атаки и задачи \textsc{Insecure} вводятся, как и прежде
(см.~Определение 2.8).  Нетрудно проверить, что формально
специфицированный выше протокол является по нашей дефиниции
небезопасным.

\subsection{Основные результаты для протоколов
            с коммутативным шифрованием}

Ниже приведены результаты, которые переносятся из случая
возведения в степень Диффи–Хеллмана практически без изменений.

\begin{theorem}[7.1]
Для RSA-нарушителя задача \textsc{Derive} решается
за детерминированное полиномиальное время.
\end{theorem}

\noindent
Доказательство повторяет рассуждения для DH-нарушителя.

\begin{theorem}[7.2]
Для RSA-нарушителя задача \textsc{Insecure} является NP-полной.
\end{theorem}

\noindent
Главное отличие от доказательства для DH-нарушителя состоит в том, что
теперь мы сводим проблему небезопасности не к решению линейных
уравнений в целых, а в \emph{неотрицательных} целых. Поскольку,
согласно \cite{BorshTreybig1976}, размер решений можно
полиномиально ограничить через размер самой системы,
мы по-прежнему получаем полиномиальную оценку размера подстановки,
необходимой для атаки, а значит — NP-алгоритм решения.
NP-трудность устанавливается так же, как и раньше.
