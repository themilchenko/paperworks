\structure{ОСНОВНАЯ ЧАСТЬ}

Прежде, чем приступить к разработки архитектуры геораспределенной системы,
необходимо описать основные механизмы, благодаря которым происходит
согласованность и целостность данных в базах данных и распределенных системах.
Такими основными системами являются журнал предзаписи (Write-Ahead Log) и
снимки текущего состояния системы (Snapshots). Более того, с помощью этих
механизмов будет построена репликация между двумя кластерами, находящих в
разных зонах доступности.

\section{Теоретические основы репликации}

Понятие теоретических основ репликации охватывает широкий круг распределённых
систем и алгоритмов, направленных на обеспечение доступности, отказоустойчивости
и согласованности данных. В общем случае к таким механизмам относятся различные
подходы к синхронизации состояний, протоколы консенсуса, а также модели
согласованности, определяющие допустимые расхождения между репликами.

В рамках данной работы рассматриваются только те механизмы репликации, которые
непосредственно применяются в реализуемой системе. Это позволяет сосредоточиться
на практических аспектах обеспечения целостности и согласованности данных,
необходимых для корректной работы механизма отказоустойчивости. Для понимания
принципов, за счёт которых достигается согласованность состояний между кластерами,
далее последовательно рассматриваются используемые в системе теоретические
основы и алгоритмы.

\subsection{Журнал предзаписи}

Журнал предзаписи (более известен, как Write-Ahead Log или сокращенно WAL) --
это широко используемая техника обеспечения атомарности и долговечности
изменений в системах управления базами данных и системах хранения данных. Идея
WAL проста и эффективна: прежде чем применять изменение к основным файлам
данных, система записывает описание этой операции в последовательный,
устойчивый (на диске) журнал. Благодаря этому, при сбое и последующем
восстановлении можно проиграть записи из журнала и восстановить согласованное
состояние данных. WAL позволяет отделить момент подтверждения операции для
клиента от фактической записи изменений в основной структуре данных, что даёт
существенные преимущества по производительности и надёжности. Например, в такой
популярной базе данных, как PostgreSQL \cite{postgres-wal}, пишется: "WAL
гарантирует, что изменения всегда сначала фиксируются в журнале, а затем
применяются к основному хранилищу. Это позволяет системе пережить сбой,
восстановив  последнее согласованное состояние на основе журнала".

WAL естественным образом служит источником событий для репликации:
реплицирующая сторона может получать записи из WAL и последовательно применять
их к своему состоянию. Такой подход гарантирует, что порядок изменений
сохраняется, а при наличии механизма снапшотинга (см. далее) при первом
подключении можно передать снапшот состояния, а затем докатать события из WAL,
начиная с индекса снапшота. Кроме того, WAL облегчает аварийное восстановление:
после краша систему можно быстро восстановить путём пролистывания последних
записей журнала и повторного применения операций.

Эти принципы проявляются во многих современных СУБД и стореджах и
документированы в официальных материалах и статьях по архитектуре баз данных.
Вот, как используется WAL в крупных базах данных:

\begin{itemize}
    \item \textbf{PostgreSQL.} WAL является центральным механизмом обеспечения
    долговечности и репликации. Все изменения логируются в сегментированные
    WAL-файлы. WAL используется для потоковой репликации, point-in-time
    recovery (PITR) и логического декодирования \cite{postgres-wal}.

    \item \textbf{etcd.} В etcd механизм WAL хранит Raft-записи (entries) и
    метаданные состояний консенсуса (term/index). WAL в etcd сегментирован
    и обеспечивает надёжное журналирование предложений (proposals) перед
    подтверждением репликации. Это подробно описано в документации
    \cite{etcd-wal}.

    \item \textbf{Tarantool.} Tarantool использует WAL для персистентности
    in-memory-данных. Каждое изменение записывается в WAL-файл (например,
    \texttt{.xlog}); при рестарте система воспроизводит журнал для
    восстановления состояния. Документация Tarantool подробно описывает формат
    WAL и стратегию ротации \cite{tarantool-wal}.
\end{itemize}

Для более глубокого понимания того, как WAL обеспечивает согласованность и
правильный порядок применения изменений, рассмотрим наглядный пример.
На рисунке~\ref{fig:wal-materialize} показано, как три параллельно
выполняющиеся транзакции формируют общий поток записей WAL.

\begin{figure}
    \centering
    \includegraphics[width=0.95\linewidth]{assets/wal_example.png}
    \caption{Отношение между временем выполнения, идентификаторами транзакций
    (XID) и порядком записей в WAL (LSN) \cite{materialize-wal}}
    \label{fig:wal-materialize}
\end{figure}

Этот пример демонстрирует важное свойство WAL: 
несмотря на асинхронность, параллельность и несовпадение порядка
начала и завершения транзакций, все операции логируются в строго линейной
последовательности (LSN), что делает возможным корректное восстановление
и репликацию.

Рассмотрим основные наблюдения, иллюстрируемые диаграммой.

1. Транзакции начинаются в одном порядке, но завершаются — в другом.
В примере транзакции получают идентификаторы XID по мере начала:
сначала XID1 (зелёная), затем XID2 (синяя), затем XID3 (красная).  
Однако порядок завершения другой: первой коммитится красная транзакция,
синяя откатывается (rollback), зелёная завершается последней.

Это подчёркивает важность ведения журнала: простой порядок по XID
не отражает реального порядка изменений и не может использоваться напрямую
для восстановления состояния.

2. WAL содержит записи даже незавершённых транзакций.
Как видно из XID2 (синяя транзакция), в WAL попадают операции
\emph{до момента коммита} транзакции. Это сделано сознательно:
PostgreSQL записывает изменения на диск по мере их поступления, чтобы
ускорить коммит (atomic commit), избегая больших задержек.

Любая система, потребляющая WAL (включая движки репликации), обязана
корректно обрабатывать такие случаи:
\begin{itemize}
    \item в случае коммита — применять операции,
    \item в случае отката — игнорировать все изменения транзакции.
\end{itemize}

3. Порядок по LSN — глобален, но не всегда совпадает с границами транзакций.
LSN присваивается каждому изменению в журнале. Однако:
\begin{itemize}
    \item операции внутри транзакции могут быть разбросаны по WAL,
    \item транзакция может иметь несколько записей,
    \item откат (rollback) делает недействительными уже записанные изменения.
\end{itemize}

Например, операции XID2 с LSN 5 и LSN 9 в результате не должны быть применены,
хотя находятся в середине WAL.

Это означает, что потребителю WAL (как и при межкластерной репликации)
необходимо:
\begin{itemize}
    \item отслеживать границы транзакций (BEGIN / COMMIT / ROLLBACK);
    \item применять только те операции, транзакции которых завершились успешно;
    \item при откате — игнорировать все операции транзакции.
\end{itemize}

4. Метка времени (timestamp) не даёт гарантии порядка.
Хотя каждая запись WAL имеет временную метку, Materialize подчёркивает, что
она не может использоваться для определения корректной последовательности:
в распределённых системах время ненадёжно, а WAL обеспечивает строгий порядок
именно через LSN.

Несмотря на широкое распространение, WAL не является универсальным решением:
в ряде систем данные записываются непосредственно в долговечные структуры,
используются альтернативные журнальные модели (например, MVCC или колонковые
commit-logs). Кроме того, синхронная запись WAL может стать узким местом для
высоконагруженных систем, поэтому на практике применяются различные компромиссы
между надёжностью и производительностью.

Тем не менее WAL остаётся фундаментальным механизмом согласованности данных
в распределённых системах и служит основой для построения эффективной
межкластерной репликации, рассматриваемой в данной работе.

\subsection{Снимки состояния}

Несмотря на фундаментальную роль журнала предзаписи (WAL), только один WAL
не может обеспечить эффективное и быстрое восстановление системы. Поскольку
журнал имеет тенденцию расти без ограничений, его применение при рестарте
или при подключении новой реплики может занять значительное время.  
Чтобы решить эту проблему, в большинстве систем управления данными используется
механизм снимков состояния (более известный как snapshots).

Снимок представляет собой полное или частичное фиксированное состояние
данных на некотором моменте времени, соответствующее определённому индексу
(WAL LSN, Raft index или внутреннему checkpoint ID). Иными словами, снимок —
это «контрольная точка» состояния, относительно которой WAL содержит только
приращение изменений.

Механизм snapshot'ов решает сразу несколько задач:

\begin{itemize}
    \item \textbf{Сокращение времени восстановления.}  
    Вместо применения потенциально гигабайтного WAL с начала времён,
    система восстанавливается из снимка, а затем воспроизводит только
    небольшую «хвостовую» часть журнала.
    \item \textbf{Ограничение роста WAL.}  
    После создания снимка и переноса состояния на стабильный носитель,
    часть старых сегментов журнала может быть безопасно удалена или
    зарезервирована в архиве. Это критически важно для систем,
    работающих без остановки годами.
    \item \textbf{Ускорение начальной синхронизации реплики.}  
    Новые узлы в кластере (или новые географически распределённые реплики)
    могут быстро загрузить снимок и затем догнаться по журналу,
    что значительно ускоряет подключение.
    \item \textbf{Основная единица консистентного состояния.}  
    Снимок представляет собой замороженную версию данных, согласованную
    по всем внутренним структурам; на нём можно строить репликацию,
    резервное копирование и тестовые окружения.
\end{itemize}

Механизм snapshot'ов используется практически во всех современных СУБД
и системах репликации:

\begin{itemize}
    \item В \textbf{PostgreSQL} снимки создаются через механизм checkpoint,
    который фиксирует состояние страниц данных и синхронизирует его с WAL.
    Хотя PostgreSQL не использует термин ``snapshot'' в контексте полного
    образа данных, checkpoint выполняет аналогичную роль: после него можно
    удалить часть старых WAL-сегментов \cite{pgsql-wal}.

    \item В \textbf{etcd} снимок является ключевым элементом реализации Raft.
    Он содержит сериализованное состояние FSM (Finite State Machine), а WAL
    уменьшается путём удаления записей, предшествующих индексу snapshot’а.
    Документация etcd подробно описывает формат snapshot-файлов и их
    восстановление \cite{etcd-wal}.

    \item В \textbf{Tarantool} существует два вида файлов: \texttt{.snap}
    (снимки состояния данных) и \texttt{.xlog} (журналы транзакций).
    Репликация строится по принципу ``snapshot + xlog tail'', что позволяет
    эффективно добавлять реплики и запускать кластер после аварии
    \cite{tarantool-wal}.
\end{itemize}

Таким образом, в реальных системах snapshot служит критически важным
механизмом, который дополняет WAL и обеспечивает не только согласованность,
но и управляемость размеров журнала.

С точки зрения теории реплицируемых состояний (replicated state machines),
снимок фиксирует состояние системы после применения всех команд из журнала
до некоторого индекса $N$. Это означает:

\[
\text{Состояние после применения WAL[1..N]} \equiv \text{Snapshot}(N)
\]

Тогда для восстановления состояния узла достаточно выполнить:

\[
\text{Restore} = \text{LoadSnapshot}(N) \; + \; \text{Replay WAL}[N+1..\text{end}]
\]
